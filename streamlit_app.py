# -*- coding: utf-8 -*-
"""brain is not braining

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aORQooRR2gkqpcKIfLG_6zBhBYw7ChKU
"""

# import system libs
import os
import time
import shutil
import pathlib
import itertools
from PIL import Image

# import data handling tools
import cv2
import numpy as np
import pandas as pd
import seaborn as sns
sns.set_style('darkgrid')
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix, classification_report

# import Deep learning Libraries
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.optimizers import Adam, Adamax
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Activation, Dropout, BatchNormalization
from tensorflow.keras import regularizers

# Ignore Warnings
import warnings
warnings.filterwarnings("ignore")

print ('modules loaded')

import zipfile
import os

# Path to the zip file
zip_file_path = '/content/archive.zip'

# Directory where you want to extract the contents
extracted_dir_path = '/content/extracted'

# Create the directory if it doesn't exist
if not os.path.exists(extracted_dir_path):
    os.makedirs(extracted_dir_path)

# Extract the contents of the zip file
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extracted_dir_path)

# After extraction, set train_data_dir to the extracted directory
train_data_dir = extracted_dir_path

# Tasvirlar saqlanadigan direktoriya
train_data_dir = '/content/extracted/Training'

from tensorflow.keras.preprocessing.image import ImageDataGenerator

# tasvirlar uchun o'lcham
img_size = (224, 224)

batch_size = 16

# ma'lumotlarni ko'paytirish parametrlari
train_datagen = ImageDataGenerator(
    rotation_range=20,  # Tasvirlarni tasodifiy ravishda 20 gradusgacha aylantirish
    width_shift_range=0.2,  # Tasvirlarni gorizontal ravishda kenglikning 20% ​​gacha o'zgartirish
    height_shift_range=0.2,  # Tasvirlarni vertikal ravishda balandlikning 20% ​​gacha siljitish
    shear_range=0.2,  # Tasvirlarni 20% gacha qirqish
    zoom_range=0.2,  # 20% gacha kattalashtirish yoki kichraytirish
    horizontal_flip=True,  # Rasmlarni gorizontal ravishda aylantirish
    vertical_flip=True,  # Tasvirlarni vertikal ravishda aylantirish
    fill_mode='nearest'  # Eng yaqin qo'shni yordamida yetishmayotgan piksellarni to'ldirish
)

# Barcha kataloglarni sanab o'tish (folds)
folds = os.listdir(train_data_dir)
filepaths = []
labels = []

# Har bir katalog bo'ylab aylanish (class)
for fold in folds:
    foldpath = os.path.join(train_data_dir, fold)
    filelist = os.listdir(foldpath)
    for file in filelist:
        fpath = os.path.join(foldpath, file)
        filepaths.append(fpath)
        labels.append(fold)

# Fayl yo'llari va teglar bilan DataFrame yaratish
Fseries = pd.Series(filepaths, name='filepaths')
Lseries = pd.Series(labels, name='labels')
data = pd.concat([Fseries, Lseries], axis=1)

# Kengaytirilgan ma'lumotlar generatorini yaratish
train_gen_augmented = train_datagen.flow_from_dataframe(
    data,
    x_col='filepaths',
    y_col='labels',
    target_size=img_size,
    class_mode='categorical',
    color_mode='rgb',
    shuffle=True,
    batch_size=batch_size
)

filepaths = []
labels = []

# List all the directories (folds)
folds = os.listdir(train_data_dir)
for fold in folds:
    foldpath = os.path.join(train_data_dir, fold)
    filelist = os.listdir(foldpath)
    for file in filelist:
        fpath = os.path.join(foldpath, file)

        filepaths.append(fpath)
        labels.append(fold)

# Create pandas Series for filepaths and labels
Fseries = pd.Series(filepaths, name='filepaths')
Lseries = pd.Series(labels, name='labels')

# Concatenate the Series into a DataFrame
data = pd.concat([Fseries, Lseries], axis=1)
data

from matplotlib import pyplot as plt
import seaborn as sns

# Define the color hex codes
colors = ['#71e381', '#fa6ed5', '#4cc4fc', '#fcf751']
text_color = '#0404cf'
background_color = 'white'
grid_color = '#bde6fc'

# Create the bar plot with specified colors
ax = data['labels'].value_counts().plot(kind='barh', color=colors)

# Set the face color of the axes patch to white
ax.set_facecolor(background_color)

# Remove top and right spines from the axes
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)

# Set the color of the text
ax.xaxis.label.set_color(text_color)
ax.yaxis.label.set_color(text_color)
ax.tick_params(axis='x', colors=text_color)
ax.tick_params(axis='y', colors=text_color)

# Set the color of the grid lines
ax.grid(color=grid_color)

# Show the plot
plt.show()

from sklearn.model_selection import train_test_split

# Split the data DataFrame into training and validation/test sets
train_df, valid_test_df = train_test_split(data, train_size=0.5, shuffle=True, random_state=123)

# Further split the validation/test set into separate validation and test sets
valid_df, test_df = train_test_split(valid_test_df, train_size=0.5, shuffle=True, random_state=123)

batch_size=16
img_size = (224,224)
channels = 3
img_shape=(img_size[0],img_size[1],channels)  #224*224*3
tr_gen = ImageDataGenerator()
ts_gen = ImageDataGenerator()
train_gen = tr_gen.flow_from_dataframe( data, x_col= 'filepaths', y_col= 'labels',
                                         target_size= img_size, class_mode= 'categorical', color_mode= 'rgb', shuffle= True,batch_size= batch_size)
test_gen = tr_gen.flow_from_dataframe( test_df, x_col= 'filepaths', y_col= 'labels',
                                         target_size= img_size, class_mode= 'categorical', color_mode= 'rgb', shuffle= False ,batch_size= batch_size)
valid_gen = tr_gen.flow_from_dataframe( valid_df, x_col= 'filepaths', y_col= 'labels',
                                         target_size= img_size, class_mode= 'categorical', color_mode= 'rgb', shuffle= True,batch_size= batch_size)

g_dict = train_gen.class_indices
classes = list(g_dict.keys())
images,labels = next(train_gen)
plt.figure(figsize = (15,15))
for i in range(16):
    plt.subplot(4,4,i+1)
    image = images[i]/255
    plt.imshow(image)
    index = np.argmax(labels[i])
    class_name= classes[index]
    plt.title(class_name,color='blue',fontsize=12)
    plt.axis('off')
plt.show();

img_size = (224, 224)
channels = 3
img_shape = (img_size[0], img_size[1], channels)
class_count = len(list(train_gen.class_indices.keys()))

base_model = tf.keras.applications.efficientnet.EfficientNetB3(include_top= False, weights= "imagenet", input_shape= img_shape, pooling= 'max')
model = Sequential([
    base_model,
    BatchNormalization(axis= -1, momentum= 0.99, epsilon= 0.001),
    Dense(256, kernel_regularizer= regularizers.l2( 0.016), activity_regularizer= regularizers.l1(0.006),
                bias_regularizer= regularizers.l1(0.006), activation= 'relu'),
    Dropout(rate= 0.45, seed= 123),
    Dense(class_count, activation= 'softmax')
])

model.compile(Adamax(learning_rate= 0.001), loss= 'categorical_crossentropy', metrics= ['accuracy'])

model.summary()
Model: "sequential_1"

epochs = 5
history = model.fit(x= train_gen, epochs= epochs, verbose= 1, validation_data= valid_gen, shuffle= False)

# Define needed variables
tr_acc = history.history['accuracy']
tr_loss = history.history['loss']
val_acc = history.history['val_accuracy']
val_loss = history.history['val_loss']
index_loss = np.argmin(val_loss)
val_lowest = val_loss[index_loss]
index_acc = np.argmax(val_acc)
acc_highest = val_acc[index_acc]
Epochs = [i+1 for i in range(len(tr_acc))]
loss_label = f'eng yaxshi epoch= {str(index_loss + 1)}'
acc_label = f'eng yaxshi epoch= {str(index_acc + 1)}'
plt.figure(figsize= (14, 6))
plt.style.use('fivethirtyeight')

plt.subplot(1, 2, 1)
plt.plot(Epochs, tr_loss, '#ffb845', label= 'Treningningda yoqotish')
plt.plot(Epochs, val_loss, '#77fcc2', label= 'tasdiqlashda yoqotish')
plt.scatter(index_loss + 1, val_lowest, s= 170, c= '#fc6f89', label= loss_label, zorder=5)
plt.title('Trening va tasdiqlash yoqotilishi', c='#25178a')
plt.xlabel('Epochlar', c='#d9556d')
plt.ylabel('Yoqotish', c='#25178a')
plt.legend()

# Set background color to white for the first subplot
plt.gca().set_facecolor('white')

plt.subplot(1, 2, 2)
plt.plot(Epochs, tr_acc, '#ffb845', label= 'Treningning aniqligi')
plt.plot(Epochs, val_acc, '#77fcc2', label= 'Tasdiqlashning aniqligi')
plt.scatter(index_acc + 1 , acc_highest, s= 170, c= '#fc6f89', label= acc_label, zorder=5)
plt.title('Trening va tasdiqlashning aniqligi', c='#25178a')
plt.xlabel('Epochlar', c='#d9556d')
plt.ylabel('Aniqlik', c='#25178a')
plt.legend()

# Set background color to white for the second subplot
plt.gca().set_facecolor('white')

plt.tight_layout()
plt.show()

train_score = model.evaluate(train_gen ,  verbose = 1)
valid_score = model.evaluate(valid_gen ,  verbose = 1)
test_score = model.evaluate(test_gen ,  verbose = 1)

preds = model.predict_generator(test_gen)

y_pred = np.argmax(preds , axis = 1)

g_dict = test_gen.class_indices
classes = list(g_dict.keys())
cm = confusion_matrix(test_gen.classes, y_pred)
cm

import matplotlib.pyplot as plt
import numpy as np

# Define custom colormap
from matplotlib.colors import LinearSegmentedColormap

colors = ['#ffffff', '#32b6fc']  # White to #86dbf7
cmap = LinearSegmentedColormap.from_list('custom', colors)

# Plot the confusion matrix
plt.figure(figsize=(9, 8.5))
plt.imshow(cm, interpolation='nearest', cmap=cmap)
plt.title('Confusion Matrix', c='#17cffc', fontweight='bold')
plt.colorbar()

tick_marks = np.arange(len(classes))
plt.xticks(tick_marks, classes, rotation=45)
plt.yticks(tick_marks, classes)

thresh = cm.max() / 2.
for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, cm[i, j], horizontalalignment='center', color='black' if cm[i, j] > thresh else 'white')

plt.tight_layout()
plt.ylabel('Haqiqiy yorliq', c='#037ffc', fontweight='bold')
plt.xlabel('Bashorat qlingan yorliq', c='#037ffc', fontweight='bold')

plt.show()

model.save("mo.h5")

